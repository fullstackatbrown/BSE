import {
  require_react
} from "./chunk-DRWLMN53.js";
import {
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/react-horizontal-scrolling-menu/dist/index.mjs
var import_react = __toESM(require_react(), 1);
var t = "react-horizontal-scrolling-menu";
var n = `${t}--item`;
var o = `${t}--scroll-container`;
var r = `${t}--wrapper`;
var s = `${t}--inner-wrapper`;
var i = `${t}--header`;
var l = `${t}--arrow-left`;
var a = `${t}--arrow-right`;
var u = `${t}--footer`;
var c = "itemId";
var d = "data-key";
var h = "data-index";
var f = { first: "first", last: "last", onInit: "onInit", onUpdate: "onUpdate" };
var v = "";
var m = { current: null };
var p = Object.freeze({ __proto__: null, rootClassName: t, itemClassName: n, scrollContainerClassName: o, wrapperClassName: r, innerWrapperClassName: s, headerClassName: i, arrowLeftClassName: l, arrowRightClassName: a, footerClassName: u, id: c, dataKeyAttribute: d, dataIndexAttribute: h, events: f, emptyStr: v, emptyRef: m });
var b = class {
  constructor() {
    this.subscribe = (e2, t2) => {
      this.observers.set(e2, (this.observers.get(e2) || []).concat(t2));
    }, this.unsubscribe = (e2, t2) => {
      const n2 = (this.observers.get(e2) || []).filter((e3) => e3 !== t2);
      n2.length ? this.observers.set(e2, n2) : this.observers.delete(e2);
    }, this.emitUpdates = (e2, t2) => {
      const n2 = this.observers.get(e2) || [];
      null == n2 || n2.forEach((e3) => e3(t2));
    }, this.updateBatch = (e2, t2 = true) => {
      e2.length && (e2.forEach(([e3, t3]) => this.emitUpdates(e3, t3)), t2 && this.emitUpdates(f.onUpdate));
    }, this.update = (e2, t2) => {
      this.emitUpdates(e2, t2), this.emitUpdates(f.onUpdate);
    }, this.observers = /* @__PURE__ */ new Map();
  }
};
var g = class extends Map {
  constructor() {
    super(), this.subscribe = (e2, t2) => this.observer.subscribe(e2, t2), this.unsubscribe = (e2, t2) => this.observer.unsubscribe(e2, t2), this.isEdgeItem = ({ key: e2, value: t2, first: n2 = this.first(), last: o2 = this.last() }) => {
      const r2 = [];
      return e2 === (null == n2 ? void 0 : n2.key) ? r2.push([f.first, t2]) : e2 === (null == o2 ? void 0 : o2.key) && r2.push([f.last, t2]), r2;
    }, this.edgeItemsCheck = (e2) => {
      const t2 = this.first(), n2 = this.last(), o2 = e2.find(([e3]) => e3 === (null == t2 ? void 0 : t2.key)), r2 = [];
      o2 && r2.push([f.first, o2[1]]);
      const s2 = e2.find(([e3]) => e3 === (null == n2 ? void 0 : n2.key));
      return s2 && r2.push([f.last, s2[1]]), r2;
    }, this.toArr = () => this.sort([...this]), this.toItems = () => this.toArr().map(([e2]) => e2), this.sort = (e2) => e2.sort(([, e3], [, t2]) => +e3.index - +t2.index), this.set = (e2, t2) => {
      const n2 = String(e2), o2 = [[n2, t2]];
      return super.set(n2, t2), o2.push(...this.isEdgeItem({ key: n2, value: t2, first: this.first(), last: this.last() })), this.observer.updateBatch(o2), this;
    }, this.setBatch = (e2) => {
      this.firstRun && this.observer.update(f.onInit);
      const t2 = [...e2];
      return this.sort(t2).forEach(([e3, t3]) => {
        super.set(String(e3), t3);
      }), t2.push(...this.edgeItemsCheck(t2)), this.observer.updateBatch(t2, !this.firstRun), this.firstRun = false, this;
    }, this.first = () => {
      var e2;
      return null === (e2 = this.toArr()[0]) || void 0 === e2 ? void 0 : e2[1];
    }, this.last = () => {
      var e2, t2;
      return null === (t2 = null === (e2 = this.toArr().slice(-1)) || void 0 === e2 ? void 0 : e2[0]) || void 0 === t2 ? void 0 : t2[1];
    }, this.filter = (e2) => this.toArr().filter(e2), this.find = (e2) => this.toArr().find(e2), this.findIndex = (e2) => this.toArr().findIndex(e2), this.getCurrentPos = (e2) => {
      const t2 = this.toArr(), n2 = t2.findIndex(([t3, n3]) => t3 === e2 || n3 === e2);
      return [t2, n2];
    }, this.prev = (e2) => {
      var t2;
      const [n2, o2] = this.getCurrentPos(e2);
      return -1 !== o2 ? null === (t2 = n2[o2 - 1]) || void 0 === t2 ? void 0 : t2[1] : void 0;
    }, this.next = (e2) => {
      var t2;
      const [n2, o2] = this.getCurrentPos(e2);
      return -1 !== o2 ? null === (t2 = n2[o2 + 1]) || void 0 === t2 ? void 0 : t2[1] : void 0;
    }, this.getVisible = () => this.filter((e2) => e2[1].visible), this.observer = new b(), this.firstRun = true;
  }
};
var y = (e2) => "object" == typeof e2 && null != e2 && 1 === e2.nodeType;
var w = (e2, t2) => (!t2 || "hidden" !== e2) && "visible" !== e2 && "clip" !== e2;
var E = (e2, t2) => {
  if (e2.clientHeight < e2.scrollHeight || e2.clientWidth < e2.scrollWidth) {
    const n2 = getComputedStyle(e2, null);
    return w(n2.overflowY, t2) || w(n2.overflowX, t2) || ((e3) => {
      const t3 = ((e4) => {
        if (!e4.ownerDocument || !e4.ownerDocument.defaultView) return null;
        try {
          return e4.ownerDocument.defaultView.frameElement;
        } catch (e5) {
          return null;
        }
      })(e3);
      return !!t3 && (t3.clientHeight < e3.scrollHeight || t3.clientWidth < e3.scrollWidth);
    })(e2);
  }
  return false;
};
var M = (e2, t2, n2, o2, r2, s2, i2, l2) => s2 < e2 && i2 > t2 || s2 > e2 && i2 < t2 ? 0 : s2 <= e2 && l2 <= n2 || i2 >= t2 && l2 >= n2 ? s2 - e2 - o2 : i2 > t2 && l2 < n2 || s2 < e2 && l2 > n2 ? i2 - t2 + r2 : 0;
var C = (e2) => {
  const t2 = e2.parentElement;
  return null == t2 ? e2.getRootNode().host || null : t2;
};
var I = (e2, t2) => {
  var n2, o2, r2, s2;
  if ("undefined" == typeof document) return [];
  const { scrollMode: i2, block: l2, inline: a2, boundary: u2, skipOverflowHiddenElements: c2 } = t2, d2 = "function" == typeof u2 ? u2 : (e3) => e3 !== u2;
  if (!y(e2)) throw new TypeError("Invalid target");
  const h2 = document.scrollingElement || document.documentElement, f2 = [];
  let v2 = e2;
  for (; y(v2) && d2(v2); ) {
    if (v2 = C(v2), v2 === h2) {
      f2.push(v2);
      break;
    }
    null != v2 && v2 === document.body && E(v2) && !E(document.documentElement) || null != v2 && E(v2, c2) && f2.push(v2);
  }
  const m2 = null != (o2 = null == (n2 = window.visualViewport) ? void 0 : n2.width) ? o2 : innerWidth, p2 = null != (s2 = null == (r2 = window.visualViewport) ? void 0 : r2.height) ? s2 : innerHeight, { scrollX: b2, scrollY: g2 } = window, { height: w2, width: I2, top: x2, right: N2, bottom: k2, left: S2 } = e2.getBoundingClientRect(), { top: R2, right: $2, bottom: B2, left: O2 } = ((e3) => {
    const t3 = window.getComputedStyle(e3);
    return { top: parseFloat(t3.scrollMarginTop) || 0, right: parseFloat(t3.scrollMarginRight) || 0, bottom: parseFloat(t3.scrollMarginBottom) || 0, left: parseFloat(t3.scrollMarginLeft) || 0 };
  })(e2);
  let T2 = "start" === l2 || "nearest" === l2 ? x2 - R2 : "end" === l2 ? k2 + B2 : x2 + w2 / 2 - R2 + B2, W2 = "center" === a2 ? S2 + I2 / 2 - O2 + $2 : "end" === a2 ? N2 + $2 : S2 - O2;
  const j2 = [];
  for (let e3 = 0; e3 < f2.length; e3++) {
    const t3 = f2[e3], { height: n3, width: o3, top: r3, right: s3, bottom: u3, left: c3 } = t3.getBoundingClientRect();
    if ("if-needed" === i2 && x2 >= 0 && S2 >= 0 && k2 <= p2 && N2 <= m2 && x2 >= r3 && k2 <= u3 && S2 >= c3 && N2 <= s3) return j2;
    const d3 = getComputedStyle(t3), v3 = parseInt(d3.borderLeftWidth, 10), y2 = parseInt(d3.borderTopWidth, 10), E2 = parseInt(d3.borderRightWidth, 10), C2 = parseInt(d3.borderBottomWidth, 10);
    let R3 = 0, $3 = 0;
    const B3 = "offsetWidth" in t3 ? t3.offsetWidth - t3.clientWidth - v3 - E2 : 0, O3 = "offsetHeight" in t3 ? t3.offsetHeight - t3.clientHeight - y2 - C2 : 0, H2 = "offsetWidth" in t3 ? 0 === t3.offsetWidth ? 0 : o3 / t3.offsetWidth : 0, L2 = "offsetHeight" in t3 ? 0 === t3.offsetHeight ? 0 : n3 / t3.offsetHeight : 0;
    if (h2 === t3) R3 = "start" === l2 ? T2 : "end" === l2 ? T2 - p2 : "nearest" === l2 ? M(g2, g2 + p2, p2, y2, C2, g2 + T2, g2 + T2 + w2, w2) : T2 - p2 / 2, $3 = "start" === a2 ? W2 : "center" === a2 ? W2 - m2 / 2 : "end" === a2 ? W2 - m2 : M(b2, b2 + m2, m2, v3, E2, b2 + W2, b2 + W2 + I2, I2), R3 = Math.max(0, R3 + g2), $3 = Math.max(0, $3 + b2);
    else {
      R3 = "start" === l2 ? T2 - r3 - y2 : "end" === l2 ? T2 - u3 + C2 + O3 : "nearest" === l2 ? M(r3, u3, n3, y2, C2 + O3, T2, T2 + w2, w2) : T2 - (r3 + n3 / 2) + O3 / 2, $3 = "start" === a2 ? W2 - c3 - v3 : "center" === a2 ? W2 - (c3 + o3 / 2) + B3 / 2 : "end" === a2 ? W2 - s3 + E2 + B3 : M(c3, s3, o3, v3, E2 + B3, W2, W2 + I2, I2);
      const { scrollLeft: e4, scrollTop: i3 } = t3;
      R3 = 0 === L2 ? 0 : Math.max(0, Math.min(i3 + R3 / L2, t3.scrollHeight - n3 / L2 + O3)), $3 = 0 === H2 ? 0 : Math.max(0, Math.min(e4 + $3 / H2, t3.scrollWidth - o3 / H2 + B3)), T2 += i3 - R3, W2 += e4 - $3;
    }
    j2.push({ el: t3, top: R3, left: $3 });
  }
  return j2;
};
function x(e2, t2) {
  if (!e2.isConnected || !((e3) => {
    let t3 = e3;
    for (; t3 && t3.parentNode; ) {
      if (t3.parentNode === document) return true;
      t3 = t3.parentNode instanceof ShadowRoot ? t3.parentNode.host : t3.parentNode;
    }
    return false;
  })(e2)) return;
  const n2 = ((e3) => {
    const t3 = window.getComputedStyle(e3);
    return { top: parseFloat(t3.scrollMarginTop) || 0, right: parseFloat(t3.scrollMarginRight) || 0, bottom: parseFloat(t3.scrollMarginBottom) || 0, left: parseFloat(t3.scrollMarginLeft) || 0 };
  })(e2);
  if (((e3) => "object" == typeof e3 && "function" == typeof e3.behavior)(t2)) return t2.behavior(I(e2, t2));
  const o2 = "boolean" == typeof t2 || null == t2 ? void 0 : t2.behavior;
  for (const { el: r2, top: s2, left: i2 } of I(e2, ((e3) => false === e3 ? { block: "end", inline: "nearest" } : ((e4) => e4 === Object(e4) && 0 !== Object.keys(e4).length)(e3) ? e3 : { block: "start", inline: "nearest" })(t2))) {
    const e3 = s2 - n2.top + n2.bottom, t3 = i2 - n2.left + n2.right;
    r2.scroll({ top: e3, left: t3, behavior: o2 });
  }
}
var N;
var k = () => (N || (N = "performance" in window ? performance.now.bind(performance) : Date.now), N());
function S(e2) {
  const t2 = k(), n2 = Math.min((t2 - e2.startTime) / e2.duration, 1), o2 = e2.ease(n2), r2 = e2.startX + (e2.x - e2.startX) * o2, s2 = e2.startY + (e2.y - e2.startY) * o2;
  e2.method(r2, s2, n2, o2), r2 !== e2.x || s2 !== e2.y ? requestAnimationFrame(() => S(e2)) : e2.cb();
}
function R(e2, t2, n2) {
  let o2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 600, r2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : (e3) => 1 + --e3 * e3 * e3 * e3 * e3, s2 = arguments.length > 5 ? arguments[5] : void 0, i2 = arguments.length > 6 ? arguments[6] : void 0;
  const l2 = e2, a2 = e2.scrollLeft, u2 = e2.scrollTop;
  S({ scrollable: l2, method: (t3, n3, o3, r3) => {
    const s3 = Math.ceil(t3), l3 = Math.ceil(n3);
    e2.scrollLeft = s3, e2.scrollTop = l3, null == i2 || i2({ target: e2, elapsed: o3, value: r3, left: s3, top: l3 });
  }, startTime: k(), startX: a2, startY: u2, x: t2, y: n2, duration: o2, ease: r2, cb: s2 });
}
var $ = function(e2, t2) {
  const n2 = t2 || {};
  return ((e3) => e3 && !e3.behavior || "smooth" === e3.behavior)(n2) ? x(e2, { block: n2.block, inline: n2.inline, scrollMode: n2.scrollMode, boundary: n2.boundary, skipOverflowHiddenElements: n2.skipOverflowHiddenElements, behavior: (e3) => Promise.all(e3.reduce((e4, t3) => {
    let { el: o2, left: r2, top: s2 } = t3;
    const i2 = o2.scrollLeft, l2 = o2.scrollTop;
    return i2 === r2 && l2 === s2 ? e4 : [...e4, new Promise((e5) => R(o2, r2, s2, n2.duration, n2.ease, () => e5({ el: o2, left: [i2, r2], top: [l2, s2] }), n2.onScrollChange))];
  }, [])) }) : Promise.resolve(x(e2, t2));
};
var B = (e2) => Object.values(e2).map((e3) => e3.current).filter(Boolean);
function O(e2, t2, n2, o2, r2, s2) {
  var i2;
  const l2 = (null === (i2 = null == e2 ? void 0 : e2.entry) || void 0 === i2 ? void 0 : i2.target) || e2;
  if (!l2) return;
  const a2 = { behavior: t2 || "smooth", inline: n2 || "end", block: o2 || "nearest" };
  return s2 ? l2.scrollIntoView(a2) : $(l2, Object.assign(Object.assign({}, r2), a2));
}
var T = (e2) => document.querySelector(`[${d}='${e2}']`);
var W = (e2) => document.querySelector(`[${h}='${e2}']`);
function j(t2) {
  return import_react.default.isValidElement(t2) && t2 || "function" == typeof t2 && import_react.default.createElement(t2, null) || !!t2 && "object" == typeof t2 && import_react.default.createElement(t2, null) || null;
}
var H = (e2) => {
  var t2;
  return String((null === (t2 = null == e2 ? void 0 : e2.props) || void 0 === t2 ? void 0 : t2[c]) || String((null == e2 ? void 0 : e2.key) || v).replace(/^\.\$/, v));
};
function L(e2) {
  return !!e2 && Object.prototype.hasOwnProperty.call(e2, "current");
}
var U = import_react.default.memo(function({ children: t2, className: n2, id: o2, index: r2, refs: s2 }) {
  const i2 = import_react.default.useRef(null);
  return s2[String(r2)] = i2, import_react.default.createElement("div", { className: n2, [d]: o2, [h]: r2, ref: i2 }, t2);
});
function A({ children: t2, itemClassName: o2 = v, refs: r2 }) {
  const s2 = import_react.default.Children.toArray(t2).filter(Boolean), i2 = import_react.default.useMemo(() => `${n} ${o2}`, [o2]);
  return s2.map((t3, n2) => {
    const o3 = H(t3);
    return import_react.default.createElement(U, { className: i2, id: o3, key: o3, refs: r2, index: n2 }, t3);
  });
}
function V({ className: t2 = v, children: n2, onScroll: r2 = () => {
}, scrollRef: s2, containerRef: i2 }) {
  const l2 = import_react.default.useMemo(() => `${o} ${t2}`, [t2]), a2 = import_react.default.useCallback((e2) => {
    L(s2) ? s2.current = e2 : s2(e2), L(i2) ? i2.current = e2 : i2(e2);
  }, [s2, i2]);
  return import_react.default.createElement("div", { className: l2, onScroll: r2, ref: a2 }, n2);
}
var F = import_react.default.createContext({});
var P = (e2) => {
  var t2;
  const n2 = e2[Math.floor(e2.length / 2)];
  return { first: null == e2 ? void 0 : e2[0], center: n2, last: null === (t2 = e2.slice(-1)) || void 0 === t2 ? void 0 : t2[0] };
};
var D = "undefined" != typeof window ? import_react.default.useLayoutEffect : import_react.default.useEffect;
function X({ items: t2, itemsChanged: n2, refs: o2, options: r2 }) {
  const s2 = import_react.default.useRef(), i2 = import_react.default.useCallback((e2) => {
    t2.setBatch(function(e3, t3) {
      return [...e3].map((e4) => {
        var n3, o3, r3, s3;
        const i3 = e4.target, l2 = String(null !== (o3 = null === (n3 = null == i3 ? void 0 : i3.dataset) || void 0 === n3 ? void 0 : n3.key) && void 0 !== o3 ? o3 : v);
        return [l2, { index: String(null !== (s3 = null === (r3 = null == i3 ? void 0 : i3.dataset) || void 0 === r3 ? void 0 : r3.index) && void 0 !== s3 ? s3 : v), key: l2, entry: e4, visible: e4.intersectionRatio >= t3.ratio }];
      });
    }(e2, r2));
  }, [t2, r2]);
  D(() => {
    const e2 = B(o2), t3 = s2.current || new IntersectionObserver(i2, r2);
    return s2.current = t3, e2.forEach((e3) => t3.observe(e3)), () => {
      t3.disconnect(), s2.current = void 0;
    };
  }, [i2, n2, r2, o2]);
}
var Y = (t2) => import_react.default.Children.toArray(t2).map(H).filter(Boolean);
var _ = { ratio: 0.9, rootMargin: "5px", threshold: [0.05, 0.5, 0.75, 0.95] };
function q(e2, t2) {
  return { prev: () => function(e3, t3) {
    const n2 = e3.findIndex((e4) => e4 === (null == t3 ? void 0 : t3[0])), o2 = t3.length, r2 = n2 - o2, s2 = r2 < 0, i2 = s2 ? 0 : r2, l2 = e3.slice(i2, s2 ? o2 : n2);
    return l2.length === o2 ? l2 : e3.slice(n2, o2);
  }(e2, t2), next: () => function(e3, t3) {
    const n2 = e3.findIndex((e4) => {
      var n3;
      return e4 === (null === (n3 = t3.slice(-1)) || void 0 === n3 ? void 0 : n3[0]);
    }), o2 = t3.length, r2 = n2 + o2 + 1, s2 = r2 > e3.length - 1, i2 = s2 ? e3.length - 1 : r2, l2 = e3.slice(s2 ? i2 - o2 + 1 : n2 + 1, i2);
    return l2.length === o2 ? l2 : e3.slice(e3.length - o2, e3.length + o2);
  }(e2, t2) };
}
var z = { current: {} };
var K = () => {
};
function G({ LeftArrow: t2, RightArrow: n2, children: o2, Header: c2, Footer: d2, transitionDuration: h2 = 500, transitionBehavior: p2, onInit: b2 = K, onUpdate: y2 = K, onMouseDown: w2, onMouseLeave: E2, onMouseUp: M2, onMouseMove: C2, onScroll: I2 = K, onTouchMove: x2, onTouchStart: N2, onTouchEnd: k2, onWheel: S2 = K, options: R2 = _, scrollContainerClassName: $2 = v, containerRef: B2 = m, itemClassName: H2 = v, wrapperClassName: U2 = v, apiRef: P2 = z, RTL: D2, noPolyfill: q2 }) {
  const G2 = j(t2), J = j(n2), Q = j(c2), Z = j(d2), ee = import_react.default.useRef(null), [te] = import_react.default.useState({}), ne = import_react.default.useMemo(() => Object.assign(Object.assign(Object.assign({}, _), R2), { root: ee.current }), [R2]), oe = import_react.default.useRef(new g()).current, re = function(t3, n3) {
    const [o3, r2] = import_react.default.useState(v), s2 = import_react.default.useMemo(() => Y(t3), [t3]);
    return import_react.default.useEffect(() => {
      const e2 = s2.filter(Boolean).join(v);
      n3.toItems().filter((e3) => !s2.includes(e3)).forEach((e3) => {
        n3.delete(e3);
      }), r2(e2);
    }, [s2, n3]), o3;
  }(o2, oe);
  X(import_react.default.useMemo(() => ({ items: oe, itemsChanged: re, options: ne, refs: te }), [oe, re, te, ne]));
  const se = import_react.default.useMemo(() => function(t3, n3, o3) {
    var r2, s2, i2;
    const l2 = !!(null === (r2 = t3.first()) || void 0 === r2 ? void 0 : r2.visible), a2 = !!(null === (s2 = t3.last()) || void 0 === s2 ? void 0 : s2.visible), u2 = (e2) => {
      var n4;
      return null === (n4 = t3.find((t4) => t4[1].key === String(e2))) || void 0 === n4 ? void 0 : n4[1];
    }, c3 = () => {
      var e2, n4;
      const o4 = null === (n4 = null === (e2 = t3.getVisible()) || void 0 === e2 ? void 0 : e2[0]) || void 0 === n4 ? void 0 : n4[1];
      return o4 ? t3.prev(o4) : void 0;
    }, d3 = () => {
      var e2;
      const n4 = null === (e2 = t3.getVisible().findLast(() => true)) || void 0 === e2 ? void 0 : e2[1];
      return n4 ? t3.next(n4) : void 0;
    }, h3 = null === (i2 = null == n3 ? void 0 : n3.boundary) || void 0 === i2 ? void 0 : i2.current;
    return { getItemById: u2, getItemElementById: T, getItemByIndex: (e2) => {
      var n4;
      return null === (n4 = t3.find((t4) => String(t4[1].index) === String(e2))) || void 0 === n4 ? void 0 : n4[1];
    }, getItemElementByIndex: W, getNextElement: d3, getPrevElement: c3, isFirstItemVisible: l2, isItemVisible: (e2) => t3.getVisible().map((e3) => e3[0]).includes(String(e2)), isLastItem: (e2) => t3.last() === u2(e2), isLastItemVisible: a2, scrollNext: (e2, t4, r3, { duration: s3, boundary: i3 = h3 } = {}) => {
      const l3 = null != e2 ? e2 : null == n3 ? void 0 : n3.behavior;
      return O(d3(), l3, t4 || "start", r3 || "nearest", { boundary: i3, duration: null != s3 ? s3 : null == n3 ? void 0 : n3.duration }, o3);
    }, scrollPrev: (e2, t4, r3, { duration: s3, boundary: i3 = h3 } = {}) => {
      const l3 = null != e2 ? e2 : null == n3 ? void 0 : n3.behavior;
      return O(c3(), l3, t4 || "end", r3 || "nearest", { boundary: i3, duration: null != s3 ? s3 : null == n3 ? void 0 : n3.duration }, o3);
    }, useIsVisible: (n4, o4 = false) => {
      const [r3, s3] = import_react.default.useState(o4), i3 = import_react.default.useCallback((e2) => {
        s3(!!(null == e2 ? void 0 : e2.visible));
      }, []);
      return import_react.default.useEffect(() => (t3.subscribe(n4, i3), () => {
        t3.unsubscribe(n4, i3);
      }), [n4, i3]), r3;
    }, scrollToItem: (e2, t4, r3, s3, i3) => {
      var l3;
      return O(e2, null != t4 ? t4 : null == n3 ? void 0 : n3.behavior, r3, s3, Object.assign(Object.assign({ boundary: h3 }, i3), { duration: null !== (l3 = null == i3 ? void 0 : i3.duration) && void 0 !== l3 ? l3 : null == n3 ? void 0 : n3.duration }), o3);
    } };
  }(oe, { duration: h2, behavior: p2, boundary: ee }, q2), [oe, h2, p2, q2]), ie = import_react.default.useCallback(() => Object.assign(Object.assign({}, se), { items: oe, scrollContainer: ee }), [se, oe, ee]), [le, ae] = import_react.default.useState(() => ie());
  (({ context: t3, onInit: n3, onUpdate: o3 }) => {
    const r2 = import_react.default.useCallback(() => n3(t3), [n3, t3]), s2 = import_react.default.useCallback(() => o3(t3), [o3, t3]), { items: i2 } = t3;
    import_react.default.useEffect(() => (i2.subscribe(f.onInit, r2), i2.subscribe(f.onUpdate, s2), () => {
      i2.unsubscribe(f.onInit, r2), i2.unsubscribe(f.onUpdate, s2);
    }), [i2, r2, s2]);
  })({ context: le, onInit: b2, onUpdate: y2 }), import_react.default.useEffect(() => ae(ie()), [ie]), import_react.default.useEffect(() => {
    L(P2) ? P2.current = le : P2(le);
  }, [le, P2]);
  const ue = import_react.default.useCallback((e2) => I2(le, e2), [I2, le]), ce = import_react.default.useCallback((e2) => S2(le, e2), [S2, le]), de = import_react.default.useMemo(() => `${r} ${U2}`, [U2]), he = import_react.default.useMemo(() => `${$2}${D2 ? " rtl" : v}`, [D2, $2]);
  return import_react.default.createElement("div", { className: de, onWheel: ce, onMouseDown: null == w2 ? void 0 : w2(le), onMouseLeave: null == E2 ? void 0 : E2(le), onMouseUp: null == M2 ? void 0 : M2(le), onMouseMove: null == C2 ? void 0 : C2(le), onTouchStart: null == N2 ? void 0 : N2(le), onTouchMove: null == x2 ? void 0 : x2(le), onTouchEnd: null == k2 ? void 0 : k2(le) }, import_react.default.createElement(F.Provider, { value: le }, import_react.default.createElement("div", { className: i }, Q), import_react.default.createElement("div", { className: s }, import_react.default.createElement("div", { className: l }, G2), import_react.default.createElement(V, { className: he, onScroll: ue, scrollRef: ee, containerRef: B2 }, import_react.default.createElement(A, { refs: te, itemClassName: H2 }, o2)), import_react.default.createElement("div", { className: a }, J)), import_react.default.createElement("div", { className: u }, Z)));
}
export {
  G as ScrollMenu,
  F as VisibilityContext,
  p as constants,
  P as getItemsPos,
  q as slidingWindow
};
//# sourceMappingURL=react-horizontal-scrolling-menu.js.map
